# algorithm-implementation
### 分治算法
```shell
分治算法：将问题划分成若干个独立的小问题，分开处理，最后合并处理结果
目录：src/divide-conquer
解决问题：求数组中的最大值和最小值
```

### 递归
```shell
递归：调用自身函数；
迭代：利用变量的原值推算出变量的一个新值
目录：src/recursion
解决问题：斐波那契数列
```
### 贪婪算法
```shell
贪婪算法：每次取局部最优解
贪心算法每一步都是最优的解决方案，但整个算法并不一定是最优的
目录：src/greedy
解决问题：部分背包问题
```
### 动态规划算法
```shell
动态规划算法：先将问题拆分成多个简单的小问题，通过逐一解决这些小问题找到整个问题的答案
与分支算法区别：
    分治算法拆分出的小问题之间是相互独立的
    动态规划算法拆分出的小问题之间相互关联，例如要想解决问题 A，必须先解决问题 B 和 C
目录：src/dynamic-programming
解决问题：0-1背包问题
```
### 排序算法

1. 冒泡排序算法：遍历待排序序列，过程中不断地比较相邻两个元素的值，如果后者比前者的值大(小)就交换它们的位置。遍历完成后，最后一个元素就是当前待排序序列中最大(最小)的。
2. 插入排序算法：初始状态下，将待排序序列中的第一个元素看作是有序的子序列。从第二个元素开始，在不破坏子序列有序的前提下，将后续的每个元素插入到子序列中的适当位置。
3. 选择排序算法：每次从待排序序列中找出最大值或最小值，查找过程重复 n-1 次。对于每次找到的最大值或最小值，通过交换元素位置的方式将它们放置到适当的位置，最终使整个序列变成有序序列。
4. 希尔排序算法：(又名缩小增量排序算法)是一种更高效的插入排序算法。和普通的插入排序算法相比，希尔排序算法减少了移动元素和比较元素大小的次数，从而提高了排序效率。
希尔排序算法的实现思路是：
```shell
    * 1. 将待排序序列划分成多个子序列，使用普通的插入排序算法对每个子序列进行排序；
    * 2. 按照不同的划分标准，重复执行第一步；
    * 3. 使用普通的插入排序算法对整个序列进行排序。
 ```
希尔排序算法没有固定的划分标准,待排序序列如何进行划分，划分多少次，都会影响到希尔排序算法的执行效率，通常采用以下方法
```javascript
 // 初始值为1
  let interval = 1;
  // 计算最大间隔
  while (interval < (_len / 3)) {
    interval = interval * 3 + 1;
  };
```
5. 归并排序算法：将整个待排序序列划分成多个不可再分的子序列，每个子序列中仅有 1 个元素；所有的子序列进行两两合并，合并过程中完成排序操作，最终合并得到的新序列就是有序序列。
合并的实现方式为：
```shell
    1. 从 [p, mid] 和 [mid+1, q] 两个区域的元素分别拷贝到 leftarr 和 rightarr 区域。
    2. 从 leftarr 和 rightarr 区域中各个取出第一个元素，比较它们的大小；
    3. 将较小的元素拷贝到 [p, q] 区域，然后从较小元素所在的区域内取出下一个元素，继续进行比较；
    4. 重复执行第 3 步，直至 leftarr 和 rightarr 内的元素全部拷贝到 [p, q] 为止。如果 leftarr 或者 rightarr 有一方为空，则直接将另一方的所有元素依次拷贝到 [p, q] 区域。
```

| 算法 | 最佳时间复杂度 | 平均时间复杂度
| ---- | ---- | ---- |
| 冒泡排序算法 | O(n) | O(n^2) |
| 插入排序算法 | O(n) | O(n^2) |
| 选择排序算法 | O(n^2) | O(n^2) |
| 希尔排序算法 | O(n^2) |        ｜
| 归并排序算法 | O(nlogn) | O(nlogn) |
| 快速排序算法 | O(nlogn) | O(nlogn) |
| 计数排序算法 | O(nlogn) | O(nlogn) |
| 基数排序算法 | O(nk) | O(nk) |
| 桶排序算法 | O(n+k) | O(n+k) |